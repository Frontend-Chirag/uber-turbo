// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v4.24.4
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "auth";

export enum FlowType {
  /** INITIAL - for initally submit form */
  INITIAL = 0,
  /** SIGN_UP - to verify email or phone number via otp */
  SIGN_UP = 1,
  /** PROGRESSIVE_SIGN_UP - optionally field for number or email */
  PROGRESSIVE_SIGN_UP = 2,
  FINAL_SIGN_UP = 3,
  LOGIN = 5,
  UNRECOGNIZED = -1,
}

export function flowTypeFromJSON(object: any): FlowType {
  switch (object) {
    case 0:
    case "INITIAL":
      return FlowType.INITIAL;
    case 1:
    case "SIGN_UP":
      return FlowType.SIGN_UP;
    case 2:
    case "PROGRESSIVE_SIGN_UP":
      return FlowType.PROGRESSIVE_SIGN_UP;
    case 3:
    case "FINAL_SIGN_UP":
      return FlowType.FINAL_SIGN_UP;
    case 5:
    case "LOGIN":
      return FlowType.LOGIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlowType.UNRECOGNIZED;
  }
}

export function flowTypeToJSON(object: FlowType): string {
  switch (object) {
    case FlowType.INITIAL:
      return "INITIAL";
    case FlowType.SIGN_UP:
      return "SIGN_UP";
    case FlowType.PROGRESSIVE_SIGN_UP:
      return "PROGRESSIVE_SIGN_UP";
    case FlowType.FINAL_SIGN_UP:
      return "FINAL_SIGN_UP";
    case FlowType.LOGIN:
      return "LOGIN";
    case FlowType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScreenType {
  PHONE_NUMBER_INITIAL = 0,
  EMAIL_ADDRESS_INITIAL = 1,
  PHONE_OTP = 2,
  EMAIL_OTP = 3,
  PHONE_NUMBER_PROGRESSIVE = 4,
  EMAIL_ADDRESS_PROGESSIVE = 5,
  FIRST_NAME_LAST_NAME = 6,
  RESET_ACCOUNT = 7,
  CONSENT = 8,
  RESEND_OTP = 9,
  UNRECOGNIZED = -1,
}

export function screenTypeFromJSON(object: any): ScreenType {
  switch (object) {
    case 0:
    case "PHONE_NUMBER_INITIAL":
      return ScreenType.PHONE_NUMBER_INITIAL;
    case 1:
    case "EMAIL_ADDRESS_INITIAL":
      return ScreenType.EMAIL_ADDRESS_INITIAL;
    case 2:
    case "PHONE_OTP":
      return ScreenType.PHONE_OTP;
    case 3:
    case "EMAIL_OTP":
      return ScreenType.EMAIL_OTP;
    case 4:
    case "PHONE_NUMBER_PROGRESSIVE":
      return ScreenType.PHONE_NUMBER_PROGRESSIVE;
    case 5:
    case "EMAIL_ADDRESS_PROGESSIVE":
      return ScreenType.EMAIL_ADDRESS_PROGESSIVE;
    case 6:
    case "FIRST_NAME_LAST_NAME":
      return ScreenType.FIRST_NAME_LAST_NAME;
    case 7:
    case "RESET_ACCOUNT":
      return ScreenType.RESET_ACCOUNT;
    case 8:
    case "CONSENT":
      return ScreenType.CONSENT;
    case 9:
    case "RESEND_OTP":
      return ScreenType.RESEND_OTP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScreenType.UNRECOGNIZED;
  }
}

export function screenTypeToJSON(object: ScreenType): string {
  switch (object) {
    case ScreenType.PHONE_NUMBER_INITIAL:
      return "PHONE_NUMBER_INITIAL";
    case ScreenType.EMAIL_ADDRESS_INITIAL:
      return "EMAIL_ADDRESS_INITIAL";
    case ScreenType.PHONE_OTP:
      return "PHONE_OTP";
    case ScreenType.EMAIL_OTP:
      return "EMAIL_OTP";
    case ScreenType.PHONE_NUMBER_PROGRESSIVE:
      return "PHONE_NUMBER_PROGRESSIVE";
    case ScreenType.EMAIL_ADDRESS_PROGESSIVE:
      return "EMAIL_ADDRESS_PROGESSIVE";
    case ScreenType.FIRST_NAME_LAST_NAME:
      return "FIRST_NAME_LAST_NAME";
    case ScreenType.RESET_ACCOUNT:
      return "RESET_ACCOUNT";
    case ScreenType.CONSENT:
      return "CONSENT";
    case ScreenType.RESEND_OTP:
      return "RESEND_OTP";
    case ScreenType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EventType {
  TypeInputEmail = 0,
  TypeInputExistingEmail = 1,
  TypeInputExistingPhone = 2,
  TypeInputMobile = 3,
  TypeSMSOTP = 4,
  TypeResetAccount = 5,
  TypeEmailOTP = 6,
  TypeInputDetails = 7,
  TypeCheckBox = 8,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "TypeInputEmail":
      return EventType.TypeInputEmail;
    case 1:
    case "TypeInputExistingEmail":
      return EventType.TypeInputExistingEmail;
    case 2:
    case "TypeInputExistingPhone":
      return EventType.TypeInputExistingPhone;
    case 3:
    case "TypeInputMobile":
      return EventType.TypeInputMobile;
    case 4:
    case "TypeSMSOTP":
      return EventType.TypeSMSOTP;
    case 5:
    case "TypeResetAccount":
      return EventType.TypeResetAccount;
    case 6:
    case "TypeEmailOTP":
      return EventType.TypeEmailOTP;
    case 7:
    case "TypeInputDetails":
      return EventType.TypeInputDetails;
    case 8:
    case "TypeCheckBox":
      return EventType.TypeCheckBox;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.TypeInputEmail:
      return "TypeInputEmail";
    case EventType.TypeInputExistingEmail:
      return "TypeInputExistingEmail";
    case EventType.TypeInputExistingPhone:
      return "TypeInputExistingPhone";
    case EventType.TypeInputMobile:
      return "TypeInputMobile";
    case EventType.TypeSMSOTP:
      return "TypeSMSOTP";
    case EventType.TypeResetAccount:
      return "TypeResetAccount";
    case EventType.TypeEmailOTP:
      return "TypeEmailOTP";
    case EventType.TypeInputDetails:
      return "TypeInputDetails";
    case EventType.TypeCheckBox:
      return "TypeCheckBox";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FieldType {
  PHONE_COUNTRY_CODE = 0,
  PHONE_NUMBER = 1,
  PHONE_SMS_OTP = 2,
  EMAIL_ADDRESS = 3,
  EMAIL_OTP_CODE = 4,
  PASSWORD = 5,
  FIRST_NAME = 6,
  LAST_NAME = 7,
  TERMS_AND_CONDITIONS = 8,
  UNRECOGNIZED = -1,
}

export function fieldTypeFromJSON(object: any): FieldType {
  switch (object) {
    case 0:
    case "PHONE_COUNTRY_CODE":
      return FieldType.PHONE_COUNTRY_CODE;
    case 1:
    case "PHONE_NUMBER":
      return FieldType.PHONE_NUMBER;
    case 2:
    case "PHONE_SMS_OTP":
      return FieldType.PHONE_SMS_OTP;
    case 3:
    case "EMAIL_ADDRESS":
      return FieldType.EMAIL_ADDRESS;
    case 4:
    case "EMAIL_OTP_CODE":
      return FieldType.EMAIL_OTP_CODE;
    case 5:
    case "PASSWORD":
      return FieldType.PASSWORD;
    case 6:
    case "FIRST_NAME":
      return FieldType.FIRST_NAME;
    case 7:
    case "LAST_NAME":
      return FieldType.LAST_NAME;
    case 8:
    case "TERMS_AND_CONDITIONS":
      return FieldType.TERMS_AND_CONDITIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldType.UNRECOGNIZED;
  }
}

export function fieldTypeToJSON(object: FieldType): string {
  switch (object) {
    case FieldType.PHONE_COUNTRY_CODE:
      return "PHONE_COUNTRY_CODE";
    case FieldType.PHONE_NUMBER:
      return "PHONE_NUMBER";
    case FieldType.PHONE_SMS_OTP:
      return "PHONE_SMS_OTP";
    case FieldType.EMAIL_ADDRESS:
      return "EMAIL_ADDRESS";
    case FieldType.EMAIL_OTP_CODE:
      return "EMAIL_OTP_CODE";
    case FieldType.PASSWORD:
      return "PASSWORD";
    case FieldType.FIRST_NAME:
      return "FIRST_NAME";
    case FieldType.LAST_NAME:
      return "LAST_NAME";
    case FieldType.TERMS_AND_CONDITIONS:
      return "TERMS_AND_CONDITIONS";
    case FieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuthRequest {
  inAuthSessionId: string;
  nextUrl: string;
  screenAnswers: ScreenAnswers[];
}

export interface ScreenAnswers {
  screenType: ScreenType;
  eventType: EventType;
  fieldAnswers: FieldAnswers[];
}

export interface FieldAnswers {
  fieldType: FieldType;
  emailAddress?: string | undefined;
  phoneNumber?: string | undefined;
  otpCode?: string | undefined;
  password?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  agreeTerms?: boolean | undefined;
  phoneCountryCode?: string | undefined;
}

export interface AuthResponse {
  success: boolean;
  message: string;
  data: AuthData | undefined;
}

export interface AuthData {
  form?: AuthForm | undefined;
  redirectUrl?: string | undefined;
}

export interface AuthForm {
  flowType: FlowType;
  screens: AuthScreen | undefined;
  inAuthSessionId: string;
}

export interface AuthScreen {
  screenType: ScreenType;
  fields: AuthField[];
  eventType: EventType;
}

export interface AuthField {
  fieldType: FieldType;
  hintValue?: string | undefined;
  profileHint?: ProfileHint | undefined;
  otpWidth?: number | undefined;
}

export interface ProfileHint {
  firstname: string;
  lastname: string;
  phonenumber: string;
  email: string;
}

export interface GetAuthSessionRequest {
  sessionId: string;
}

function createBaseAuthRequest(): AuthRequest {
  return { inAuthSessionId: "", nextUrl: "", screenAnswers: [] };
}

export const AuthRequest: MessageFns<AuthRequest> = {
  encode(message: AuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inAuthSessionId !== "") {
      writer.uint32(10).string(message.inAuthSessionId);
    }
    if (message.nextUrl !== "") {
      writer.uint32(18).string(message.nextUrl);
    }
    for (const v of message.screenAnswers) {
      ScreenAnswers.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inAuthSessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.screenAnswers.push(ScreenAnswers.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthRequest {
    return {
      inAuthSessionId: isSet(object.inAuthSessionId) ? globalThis.String(object.inAuthSessionId) : "",
      nextUrl: isSet(object.nextUrl) ? globalThis.String(object.nextUrl) : "",
      screenAnswers: globalThis.Array.isArray(object?.screenAnswers)
        ? object.screenAnswers.map((e: any) => ScreenAnswers.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AuthRequest): unknown {
    const obj: any = {};
    if (message.inAuthSessionId !== "") {
      obj.inAuthSessionId = message.inAuthSessionId;
    }
    if (message.nextUrl !== "") {
      obj.nextUrl = message.nextUrl;
    }
    if (message.screenAnswers?.length) {
      obj.screenAnswers = message.screenAnswers.map((e) => ScreenAnswers.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthRequest>, I>>(base?: I): AuthRequest {
    return AuthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthRequest>, I>>(object: I): AuthRequest {
    const message = createBaseAuthRequest();
    message.inAuthSessionId = object.inAuthSessionId ?? "";
    message.nextUrl = object.nextUrl ?? "";
    message.screenAnswers = object.screenAnswers?.map((e) => ScreenAnswers.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScreenAnswers(): ScreenAnswers {
  return { screenType: 0, eventType: 0, fieldAnswers: [] };
}

export const ScreenAnswers: MessageFns<ScreenAnswers> = {
  encode(message: ScreenAnswers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.screenType !== 0) {
      writer.uint32(8).int32(message.screenType);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    for (const v of message.fieldAnswers) {
      FieldAnswers.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenAnswers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenAnswers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.screenType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fieldAnswers.push(FieldAnswers.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenAnswers {
    return {
      screenType: isSet(object.screenType) ? screenTypeFromJSON(object.screenType) : 0,
      eventType: isSet(object.eventType) ? eventTypeFromJSON(object.eventType) : 0,
      fieldAnswers: globalThis.Array.isArray(object?.fieldAnswers)
        ? object.fieldAnswers.map((e: any) => FieldAnswers.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ScreenAnswers): unknown {
    const obj: any = {};
    if (message.screenType !== 0) {
      obj.screenType = screenTypeToJSON(message.screenType);
    }
    if (message.eventType !== 0) {
      obj.eventType = eventTypeToJSON(message.eventType);
    }
    if (message.fieldAnswers?.length) {
      obj.fieldAnswers = message.fieldAnswers.map((e) => FieldAnswers.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenAnswers>, I>>(base?: I): ScreenAnswers {
    return ScreenAnswers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenAnswers>, I>>(object: I): ScreenAnswers {
    const message = createBaseScreenAnswers();
    message.screenType = object.screenType ?? 0;
    message.eventType = object.eventType ?? 0;
    message.fieldAnswers = object.fieldAnswers?.map((e) => FieldAnswers.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldAnswers(): FieldAnswers {
  return {
    fieldType: 0,
    emailAddress: undefined,
    phoneNumber: undefined,
    otpCode: undefined,
    password: undefined,
    firstName: undefined,
    lastName: undefined,
    agreeTerms: undefined,
    phoneCountryCode: undefined,
  };
}

export const FieldAnswers: MessageFns<FieldAnswers> = {
  encode(message: FieldAnswers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.emailAddress !== undefined) {
      writer.uint32(18).string(message.emailAddress);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.otpCode !== undefined) {
      writer.uint32(34).string(message.otpCode);
    }
    if (message.password !== undefined) {
      writer.uint32(42).string(message.password);
    }
    if (message.firstName !== undefined) {
      writer.uint32(50).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(58).string(message.lastName);
    }
    if (message.agreeTerms !== undefined) {
      writer.uint32(64).bool(message.agreeTerms);
    }
    if (message.phoneCountryCode !== undefined) {
      writer.uint32(74).string(message.phoneCountryCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldAnswers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldAnswers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.otpCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.agreeTerms = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.phoneCountryCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldAnswers {
    return {
      fieldType: isSet(object.fieldType) ? fieldTypeFromJSON(object.fieldType) : 0,
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      otpCode: isSet(object.otpCode) ? globalThis.String(object.otpCode) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      agreeTerms: isSet(object.agreeTerms) ? globalThis.Boolean(object.agreeTerms) : undefined,
      phoneCountryCode: isSet(object.phoneCountryCode) ? globalThis.String(object.phoneCountryCode) : undefined,
    };
  },

  toJSON(message: FieldAnswers): unknown {
    const obj: any = {};
    if (message.fieldType !== 0) {
      obj.fieldType = fieldTypeToJSON(message.fieldType);
    }
    if (message.emailAddress !== undefined) {
      obj.emailAddress = message.emailAddress;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.otpCode !== undefined) {
      obj.otpCode = message.otpCode;
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.agreeTerms !== undefined) {
      obj.agreeTerms = message.agreeTerms;
    }
    if (message.phoneCountryCode !== undefined) {
      obj.phoneCountryCode = message.phoneCountryCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldAnswers>, I>>(base?: I): FieldAnswers {
    return FieldAnswers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldAnswers>, I>>(object: I): FieldAnswers {
    const message = createBaseFieldAnswers();
    message.fieldType = object.fieldType ?? 0;
    message.emailAddress = object.emailAddress ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.otpCode = object.otpCode ?? undefined;
    message.password = object.password ?? undefined;
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.agreeTerms = object.agreeTerms ?? undefined;
    message.phoneCountryCode = object.phoneCountryCode ?? undefined;
    return message;
  },
};

function createBaseAuthResponse(): AuthResponse {
  return { success: false, message: "", data: undefined };
}

export const AuthResponse: MessageFns<AuthResponse> = {
  encode(message: AuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      AuthData.encode(message.data, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = AuthData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? AuthData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: AuthResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = AuthData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthResponse>, I>>(base?: I): AuthResponse {
    return AuthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthResponse>, I>>(object: I): AuthResponse {
    const message = createBaseAuthResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? AuthData.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseAuthData(): AuthData {
  return { form: undefined, redirectUrl: undefined };
}

export const AuthData: MessageFns<AuthData> = {
  encode(message: AuthData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.form !== undefined) {
      AuthForm.encode(message.form, writer.uint32(10).fork()).join();
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(18).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.form = AuthForm.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthData {
    return {
      form: isSet(object.form) ? AuthForm.fromJSON(object.form) : undefined,
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : undefined,
    };
  },

  toJSON(message: AuthData): unknown {
    const obj: any = {};
    if (message.form !== undefined) {
      obj.form = AuthForm.toJSON(message.form);
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthData>, I>>(base?: I): AuthData {
    return AuthData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthData>, I>>(object: I): AuthData {
    const message = createBaseAuthData();
    message.form = (object.form !== undefined && object.form !== null) ? AuthForm.fromPartial(object.form) : undefined;
    message.redirectUrl = object.redirectUrl ?? undefined;
    return message;
  },
};

function createBaseAuthForm(): AuthForm {
  return { flowType: 0, screens: undefined, inAuthSessionId: "" };
}

export const AuthForm: MessageFns<AuthForm> = {
  encode(message: AuthForm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flowType !== 0) {
      writer.uint32(8).int32(message.flowType);
    }
    if (message.screens !== undefined) {
      AuthScreen.encode(message.screens, writer.uint32(18).fork()).join();
    }
    if (message.inAuthSessionId !== "") {
      writer.uint32(26).string(message.inAuthSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthForm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.flowType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.screens = AuthScreen.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inAuthSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthForm {
    return {
      flowType: isSet(object.flowType) ? flowTypeFromJSON(object.flowType) : 0,
      screens: isSet(object.screens) ? AuthScreen.fromJSON(object.screens) : undefined,
      inAuthSessionId: isSet(object.inAuthSessionId) ? globalThis.String(object.inAuthSessionId) : "",
    };
  },

  toJSON(message: AuthForm): unknown {
    const obj: any = {};
    if (message.flowType !== 0) {
      obj.flowType = flowTypeToJSON(message.flowType);
    }
    if (message.screens !== undefined) {
      obj.screens = AuthScreen.toJSON(message.screens);
    }
    if (message.inAuthSessionId !== "") {
      obj.inAuthSessionId = message.inAuthSessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthForm>, I>>(base?: I): AuthForm {
    return AuthForm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthForm>, I>>(object: I): AuthForm {
    const message = createBaseAuthForm();
    message.flowType = object.flowType ?? 0;
    message.screens = (object.screens !== undefined && object.screens !== null)
      ? AuthScreen.fromPartial(object.screens)
      : undefined;
    message.inAuthSessionId = object.inAuthSessionId ?? "";
    return message;
  },
};

function createBaseAuthScreen(): AuthScreen {
  return { screenType: 0, fields: [], eventType: 0 };
}

export const AuthScreen: MessageFns<AuthScreen> = {
  encode(message: AuthScreen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.screenType !== 0) {
      writer.uint32(8).int32(message.screenType);
    }
    for (const v of message.fields) {
      AuthField.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthScreen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthScreen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.screenType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(AuthField.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthScreen {
    return {
      screenType: isSet(object.screenType) ? screenTypeFromJSON(object.screenType) : 0,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => AuthField.fromJSON(e)) : [],
      eventType: isSet(object.eventType) ? eventTypeFromJSON(object.eventType) : 0,
    };
  },

  toJSON(message: AuthScreen): unknown {
    const obj: any = {};
    if (message.screenType !== 0) {
      obj.screenType = screenTypeToJSON(message.screenType);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => AuthField.toJSON(e));
    }
    if (message.eventType !== 0) {
      obj.eventType = eventTypeToJSON(message.eventType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthScreen>, I>>(base?: I): AuthScreen {
    return AuthScreen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthScreen>, I>>(object: I): AuthScreen {
    const message = createBaseAuthScreen();
    message.screenType = object.screenType ?? 0;
    message.fields = object.fields?.map((e) => AuthField.fromPartial(e)) || [];
    message.eventType = object.eventType ?? 0;
    return message;
  },
};

function createBaseAuthField(): AuthField {
  return { fieldType: 0, hintValue: undefined, profileHint: undefined, otpWidth: undefined };
}

export const AuthField: MessageFns<AuthField> = {
  encode(message: AuthField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldType !== 0) {
      writer.uint32(8).int32(message.fieldType);
    }
    if (message.hintValue !== undefined) {
      writer.uint32(18).string(message.hintValue);
    }
    if (message.profileHint !== undefined) {
      ProfileHint.encode(message.profileHint, writer.uint32(26).fork()).join();
    }
    if (message.otpWidth !== undefined) {
      writer.uint32(32).int32(message.otpWidth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fieldType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hintValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profileHint = ProfileHint.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.otpWidth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthField {
    return {
      fieldType: isSet(object.fieldType) ? fieldTypeFromJSON(object.fieldType) : 0,
      hintValue: isSet(object.hintValue) ? globalThis.String(object.hintValue) : undefined,
      profileHint: isSet(object.profileHint) ? ProfileHint.fromJSON(object.profileHint) : undefined,
      otpWidth: isSet(object.otpWidth) ? globalThis.Number(object.otpWidth) : undefined,
    };
  },

  toJSON(message: AuthField): unknown {
    const obj: any = {};
    if (message.fieldType !== 0) {
      obj.fieldType = fieldTypeToJSON(message.fieldType);
    }
    if (message.hintValue !== undefined) {
      obj.hintValue = message.hintValue;
    }
    if (message.profileHint !== undefined) {
      obj.profileHint = ProfileHint.toJSON(message.profileHint);
    }
    if (message.otpWidth !== undefined) {
      obj.otpWidth = Math.round(message.otpWidth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthField>, I>>(base?: I): AuthField {
    return AuthField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthField>, I>>(object: I): AuthField {
    const message = createBaseAuthField();
    message.fieldType = object.fieldType ?? 0;
    message.hintValue = object.hintValue ?? undefined;
    message.profileHint = (object.profileHint !== undefined && object.profileHint !== null)
      ? ProfileHint.fromPartial(object.profileHint)
      : undefined;
    message.otpWidth = object.otpWidth ?? undefined;
    return message;
  },
};

function createBaseProfileHint(): ProfileHint {
  return { firstname: "", lastname: "", phonenumber: "", email: "" };
}

export const ProfileHint: MessageFns<ProfileHint> = {
  encode(message: ProfileHint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstname !== "") {
      writer.uint32(10).string(message.firstname);
    }
    if (message.lastname !== "") {
      writer.uint32(18).string(message.lastname);
    }
    if (message.phonenumber !== "") {
      writer.uint32(26).string(message.phonenumber);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileHint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileHint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phonenumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileHint {
    return {
      firstname: isSet(object.firstname) ? globalThis.String(object.firstname) : "",
      lastname: isSet(object.lastname) ? globalThis.String(object.lastname) : "",
      phonenumber: isSet(object.phonenumber) ? globalThis.String(object.phonenumber) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: ProfileHint): unknown {
    const obj: any = {};
    if (message.firstname !== "") {
      obj.firstname = message.firstname;
    }
    if (message.lastname !== "") {
      obj.lastname = message.lastname;
    }
    if (message.phonenumber !== "") {
      obj.phonenumber = message.phonenumber;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileHint>, I>>(base?: I): ProfileHint {
    return ProfileHint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileHint>, I>>(object: I): ProfileHint {
    const message = createBaseProfileHint();
    message.firstname = object.firstname ?? "";
    message.lastname = object.lastname ?? "";
    message.phonenumber = object.phonenumber ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGetAuthSessionRequest(): GetAuthSessionRequest {
  return { sessionId: "" };
}

export const GetAuthSessionRequest: MessageFns<GetAuthSessionRequest> = {
  encode(message: GetAuthSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuthSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: GetAuthSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuthSessionRequest>, I>>(base?: I): GetAuthSessionRequest {
    return GetAuthSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuthSessionRequest>, I>>(object: I): GetAuthSessionRequest {
    const message = createBaseGetAuthSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  submitAuth: {
    path: "/auth.AuthService/SubmitAuth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuthRequest): Buffer => Buffer.from(AuthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AuthRequest => AuthRequest.decode(value),
    responseSerialize: (value: AuthResponse): Buffer => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthResponse => AuthResponse.decode(value),
  },
  getAuthSession: {
    path: "/auth.AuthService/GetAuthSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthSessionRequest): Buffer =>
      Buffer.from(GetAuthSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthSessionRequest => GetAuthSessionRequest.decode(value),
    responseSerialize: (value: AuthResponse): Buffer => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthResponse => AuthResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  submitAuth: handleUnaryCall<AuthRequest, AuthResponse>;
  getAuthSession: handleUnaryCall<GetAuthSessionRequest, AuthResponse>;
}

export interface AuthServiceClient extends Client {
  submitAuth(
    request: AuthRequest,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
  submitAuth(
    request: AuthRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
  submitAuth(
    request: AuthRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
  getAuthSession(
    request: GetAuthSessionRequest,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
  getAuthSession(
    request: GetAuthSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
  getAuthSession(
    request: GetAuthSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuthResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(AuthServiceService, "auth.AuthService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
