// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.24.4
// source: place.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "place";

export interface LatLng {
  latitude: number;
  longitude: number;
}

/**
 * ============================================
 * Raw Google Places API Response Structures
 * (Mirrors actual Google API responses)
 * // Update your proto file
 */
export interface RawPlace {
  /** Keep as place_id (Google uses this) */
  placeId: string;
  name: string;
  formattedAddress: string;
  /** Keep as address_components */
  addressComponents: AddressComponent[];
  types: string[];
  /** Keep as plus_code */
  plusCode:
    | PlusCode
    | undefined;
  /** Additional fields */
  formattedPhoneNumber: string;
  internationalPhoneNumber: string;
  website: string;
  rating: number;
  userRatingsTotal: number;
  openingHours: OpeningHours | undefined;
  photos: Photo[];
  businessStatus: string;
  icon: string;
  iconBackgroundColor: string;
  iconMaskBaseUri: string;
  vicinity: string;
  utcOffset: number;
  adrAddress: string;
}

export interface AddressComponent {
  /** Keep as long_name */
  longName: string;
  /** Keep as short_name */
  shortName: string;
  types: string[];
}

export interface Location {
  /** Keep as lat */
  lat: number;
  /** Keep as lng */
  lng: number;
}

export interface PlusCode {
  globalCode: string;
  compoundCode: string;
}

export interface OpeningHours {
  openNow: boolean;
  weekdayText: string[];
}

export interface Photo {
  height: number;
  width: number;
  photoReference: string;
}

/** Place Details */
export interface GetPlaceRequest {
  /** Required (message field) */
  location:
    | LatLng
    | undefined;
  /** Optional (string) */
  placeId: string;
  /** Optional array/list of strings */
  fields: string[];
}

export interface GetPlaceResponse {
  result: RawPlace | undefined;
  status: string;
}

/** Text Search */
export interface TextSearchRequest {
  query: string;
  location: LatLng | undefined;
  radius: number;
  /** Optional: restrict to specific type */
  type: string;
  /** How many results to return */
  maxResults: number;
  /** For pagination */
  pageToken: string;
}

export interface TextSearchResponse {
  results: RawPlace[];
  status: string;
  /** For pagination */
  nextPageToken: string;
}

/** Nearby Search */
export interface NearbySearchRequest {
  location: LatLng | undefined;
  radius: number;
  keyword: string;
  type: string;
  maxResults: number;
  pageToken: string;
}

export interface NearbySearchResponse {
  results: RawPlace[];
  status: string;
  nextPageToken: string;
}

/** Autocomplete */
export interface AutocompleteRequest {
  input: string;
  location: LatLng | undefined;
  radius: number;
  types: string[];
}

export interface AutocompletePrediction {
  description: string;
  placeId: string;
  reference: string;
  types: string[];
  structuredFormatting: StructuredFormatting | undefined;
  matchedSubstrings: MatchedSubstring[];
  terms: Term[];
}

export interface StructuredFormatting {
  mainText: string;
  mainTextMatchedSubstrings: MatchedSubstring[];
  secondaryText: string;
}

export interface MatchedSubstring {
  length: number;
  offset: number;
}

export interface Term {
  offset: number;
  value: string;
}

export interface AutocompleteResponse {
  predictions: AutocompletePrediction[];
  status: string;
}

function createBaseLatLng(): LatLng {
  return { latitude: 0, longitude: 0 };
}

export const LatLng: MessageFns<LatLng> = {
  encode(message: LatLng, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatLng {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatLng();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatLng {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: LatLng): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LatLng>, I>>(base?: I): LatLng {
    return LatLng.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LatLng>, I>>(object: I): LatLng {
    const message = createBaseLatLng();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseRawPlace(): RawPlace {
  return {
    placeId: "",
    name: "",
    formattedAddress: "",
    addressComponents: [],
    types: [],
    plusCode: undefined,
    formattedPhoneNumber: "",
    internationalPhoneNumber: "",
    website: "",
    rating: 0,
    userRatingsTotal: 0,
    openingHours: undefined,
    photos: [],
    businessStatus: "",
    icon: "",
    iconBackgroundColor: "",
    iconMaskBaseUri: "",
    vicinity: "",
    utcOffset: 0,
    adrAddress: "",
  };
}

export const RawPlace: MessageFns<RawPlace> = {
  encode(message: RawPlace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== "") {
      writer.uint32(10).string(message.placeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.formattedAddress !== "") {
      writer.uint32(26).string(message.formattedAddress);
    }
    for (const v of message.addressComponents) {
      AddressComponent.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.types) {
      writer.uint32(50).string(v!);
    }
    if (message.plusCode !== undefined) {
      PlusCode.encode(message.plusCode, writer.uint32(58).fork()).join();
    }
    if (message.formattedPhoneNumber !== "") {
      writer.uint32(66).string(message.formattedPhoneNumber);
    }
    if (message.internationalPhoneNumber !== "") {
      writer.uint32(74).string(message.internationalPhoneNumber);
    }
    if (message.website !== "") {
      writer.uint32(82).string(message.website);
    }
    if (message.rating !== 0) {
      writer.uint32(89).double(message.rating);
    }
    if (message.userRatingsTotal !== 0) {
      writer.uint32(96).int32(message.userRatingsTotal);
    }
    if (message.openingHours !== undefined) {
      OpeningHours.encode(message.openingHours, writer.uint32(106).fork()).join();
    }
    for (const v of message.photos) {
      Photo.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.businessStatus !== "") {
      writer.uint32(122).string(message.businessStatus);
    }
    if (message.icon !== "") {
      writer.uint32(130).string(message.icon);
    }
    if (message.iconBackgroundColor !== "") {
      writer.uint32(138).string(message.iconBackgroundColor);
    }
    if (message.iconMaskBaseUri !== "") {
      writer.uint32(146).string(message.iconMaskBaseUri);
    }
    if (message.vicinity !== "") {
      writer.uint32(154).string(message.vicinity);
    }
    if (message.utcOffset !== 0) {
      writer.uint32(160).int32(message.utcOffset);
    }
    if (message.adrAddress !== "") {
      writer.uint32(170).string(message.adrAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawPlace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawPlace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.placeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.formattedAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addressComponents.push(AddressComponent.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.types.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.plusCode = PlusCode.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.formattedPhoneNumber = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.internationalPhoneNumber = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.rating = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userRatingsTotal = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.openingHours = OpeningHours.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.photos.push(Photo.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.businessStatus = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.iconBackgroundColor = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.iconMaskBaseUri = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.vicinity = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.utcOffset = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.adrAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawPlace {
    return {
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      formattedAddress: isSet(object.formattedAddress) ? globalThis.String(object.formattedAddress) : "",
      addressComponents: globalThis.Array.isArray(object?.addressComponents)
        ? object.addressComponents.map((e: any) => AddressComponent.fromJSON(e))
        : [],
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      plusCode: isSet(object.plusCode) ? PlusCode.fromJSON(object.plusCode) : undefined,
      formattedPhoneNumber: isSet(object.formattedPhoneNumber) ? globalThis.String(object.formattedPhoneNumber) : "",
      internationalPhoneNumber: isSet(object.internationalPhoneNumber)
        ? globalThis.String(object.internationalPhoneNumber)
        : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
      rating: isSet(object.rating) ? globalThis.Number(object.rating) : 0,
      userRatingsTotal: isSet(object.userRatingsTotal) ? globalThis.Number(object.userRatingsTotal) : 0,
      openingHours: isSet(object.openingHours) ? OpeningHours.fromJSON(object.openingHours) : undefined,
      photos: globalThis.Array.isArray(object?.photos) ? object.photos.map((e: any) => Photo.fromJSON(e)) : [],
      businessStatus: isSet(object.businessStatus) ? globalThis.String(object.businessStatus) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      iconBackgroundColor: isSet(object.iconBackgroundColor) ? globalThis.String(object.iconBackgroundColor) : "",
      iconMaskBaseUri: isSet(object.iconMaskBaseUri) ? globalThis.String(object.iconMaskBaseUri) : "",
      vicinity: isSet(object.vicinity) ? globalThis.String(object.vicinity) : "",
      utcOffset: isSet(object.utcOffset) ? globalThis.Number(object.utcOffset) : 0,
      adrAddress: isSet(object.adrAddress) ? globalThis.String(object.adrAddress) : "",
    };
  },

  toJSON(message: RawPlace): unknown {
    const obj: any = {};
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.formattedAddress !== "") {
      obj.formattedAddress = message.formattedAddress;
    }
    if (message.addressComponents?.length) {
      obj.addressComponents = message.addressComponents.map((e) => AddressComponent.toJSON(e));
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.plusCode !== undefined) {
      obj.plusCode = PlusCode.toJSON(message.plusCode);
    }
    if (message.formattedPhoneNumber !== "") {
      obj.formattedPhoneNumber = message.formattedPhoneNumber;
    }
    if (message.internationalPhoneNumber !== "") {
      obj.internationalPhoneNumber = message.internationalPhoneNumber;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.rating !== 0) {
      obj.rating = message.rating;
    }
    if (message.userRatingsTotal !== 0) {
      obj.userRatingsTotal = Math.round(message.userRatingsTotal);
    }
    if (message.openingHours !== undefined) {
      obj.openingHours = OpeningHours.toJSON(message.openingHours);
    }
    if (message.photos?.length) {
      obj.photos = message.photos.map((e) => Photo.toJSON(e));
    }
    if (message.businessStatus !== "") {
      obj.businessStatus = message.businessStatus;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.iconBackgroundColor !== "") {
      obj.iconBackgroundColor = message.iconBackgroundColor;
    }
    if (message.iconMaskBaseUri !== "") {
      obj.iconMaskBaseUri = message.iconMaskBaseUri;
    }
    if (message.vicinity !== "") {
      obj.vicinity = message.vicinity;
    }
    if (message.utcOffset !== 0) {
      obj.utcOffset = Math.round(message.utcOffset);
    }
    if (message.adrAddress !== "") {
      obj.adrAddress = message.adrAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RawPlace>, I>>(base?: I): RawPlace {
    return RawPlace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawPlace>, I>>(object: I): RawPlace {
    const message = createBaseRawPlace();
    message.placeId = object.placeId ?? "";
    message.name = object.name ?? "";
    message.formattedAddress = object.formattedAddress ?? "";
    message.addressComponents = object.addressComponents?.map((e) => AddressComponent.fromPartial(e)) || [];
    message.types = object.types?.map((e) => e) || [];
    message.plusCode = (object.plusCode !== undefined && object.plusCode !== null)
      ? PlusCode.fromPartial(object.plusCode)
      : undefined;
    message.formattedPhoneNumber = object.formattedPhoneNumber ?? "";
    message.internationalPhoneNumber = object.internationalPhoneNumber ?? "";
    message.website = object.website ?? "";
    message.rating = object.rating ?? 0;
    message.userRatingsTotal = object.userRatingsTotal ?? 0;
    message.openingHours = (object.openingHours !== undefined && object.openingHours !== null)
      ? OpeningHours.fromPartial(object.openingHours)
      : undefined;
    message.photos = object.photos?.map((e) => Photo.fromPartial(e)) || [];
    message.businessStatus = object.businessStatus ?? "";
    message.icon = object.icon ?? "";
    message.iconBackgroundColor = object.iconBackgroundColor ?? "";
    message.iconMaskBaseUri = object.iconMaskBaseUri ?? "";
    message.vicinity = object.vicinity ?? "";
    message.utcOffset = object.utcOffset ?? 0;
    message.adrAddress = object.adrAddress ?? "";
    return message;
  },
};

function createBaseAddressComponent(): AddressComponent {
  return { longName: "", shortName: "", types: [] };
}

export const AddressComponent: MessageFns<AddressComponent> = {
  encode(message: AddressComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.longName !== "") {
      writer.uint32(10).string(message.longName);
    }
    if (message.shortName !== "") {
      writer.uint32(18).string(message.shortName);
    }
    for (const v of message.types) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.longName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shortName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.types.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressComponent {
    return {
      longName: isSet(object.longName) ? globalThis.String(object.longName) : "",
      shortName: isSet(object.shortName) ? globalThis.String(object.shortName) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AddressComponent): unknown {
    const obj: any = {};
    if (message.longName !== "") {
      obj.longName = message.longName;
    }
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressComponent>, I>>(base?: I): AddressComponent {
    return AddressComponent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressComponent>, I>>(object: I): AddressComponent {
    const message = createBaseAddressComponent();
    message.longName = object.longName ?? "";
    message.shortName = object.shortName ?? "";
    message.types = object.types?.map((e) => e) || [];
    return message;
  },
};

function createBaseLocation(): Location {
  return { lat: 0, lng: 0 };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lat !== 0) {
      writer.uint32(9).double(message.lat);
    }
    if (message.lng !== 0) {
      writer.uint32(17).double(message.lng);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.lat = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lng = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      lat: isSet(object.lat) ? globalThis.Number(object.lat) : 0,
      lng: isSet(object.lng) ? globalThis.Number(object.lng) : 0,
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.lat !== 0) {
      obj.lat = message.lat;
    }
    if (message.lng !== 0) {
      obj.lng = message.lng;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Location>, I>>(base?: I): Location {
    return Location.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Location>, I>>(object: I): Location {
    const message = createBaseLocation();
    message.lat = object.lat ?? 0;
    message.lng = object.lng ?? 0;
    return message;
  },
};

function createBasePlusCode(): PlusCode {
  return { globalCode: "", compoundCode: "" };
}

export const PlusCode: MessageFns<PlusCode> = {
  encode(message: PlusCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalCode !== "") {
      writer.uint32(10).string(message.globalCode);
    }
    if (message.compoundCode !== "") {
      writer.uint32(18).string(message.compoundCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlusCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlusCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.globalCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.compoundCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlusCode {
    return {
      globalCode: isSet(object.globalCode) ? globalThis.String(object.globalCode) : "",
      compoundCode: isSet(object.compoundCode) ? globalThis.String(object.compoundCode) : "",
    };
  },

  toJSON(message: PlusCode): unknown {
    const obj: any = {};
    if (message.globalCode !== "") {
      obj.globalCode = message.globalCode;
    }
    if (message.compoundCode !== "") {
      obj.compoundCode = message.compoundCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlusCode>, I>>(base?: I): PlusCode {
    return PlusCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlusCode>, I>>(object: I): PlusCode {
    const message = createBasePlusCode();
    message.globalCode = object.globalCode ?? "";
    message.compoundCode = object.compoundCode ?? "";
    return message;
  },
};

function createBaseOpeningHours(): OpeningHours {
  return { openNow: false, weekdayText: [] };
}

export const OpeningHours: MessageFns<OpeningHours> = {
  encode(message: OpeningHours, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.openNow !== false) {
      writer.uint32(8).bool(message.openNow);
    }
    for (const v of message.weekdayText) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpeningHours {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpeningHours();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.openNow = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.weekdayText.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpeningHours {
    return {
      openNow: isSet(object.openNow) ? globalThis.Boolean(object.openNow) : false,
      weekdayText: globalThis.Array.isArray(object?.weekdayText)
        ? object.weekdayText.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OpeningHours): unknown {
    const obj: any = {};
    if (message.openNow !== false) {
      obj.openNow = message.openNow;
    }
    if (message.weekdayText?.length) {
      obj.weekdayText = message.weekdayText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpeningHours>, I>>(base?: I): OpeningHours {
    return OpeningHours.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpeningHours>, I>>(object: I): OpeningHours {
    const message = createBaseOpeningHours();
    message.openNow = object.openNow ?? false;
    message.weekdayText = object.weekdayText?.map((e) => e) || [];
    return message;
  },
};

function createBasePhoto(): Photo {
  return { height: 0, width: 0, photoReference: "" };
}

export const Photo: MessageFns<Photo> = {
  encode(message: Photo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.photoReference !== "") {
      writer.uint32(34).string(message.photoReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Photo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.photoReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Photo {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      photoReference: isSet(object.photoReference) ? globalThis.String(object.photoReference) : "",
    };
  },

  toJSON(message: Photo): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.photoReference !== "") {
      obj.photoReference = message.photoReference;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Photo>, I>>(base?: I): Photo {
    return Photo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Photo>, I>>(object: I): Photo {
    const message = createBasePhoto();
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.photoReference = object.photoReference ?? "";
    return message;
  },
};

function createBaseGetPlaceRequest(): GetPlaceRequest {
  return { location: undefined, placeId: "", fields: [] };
}

export const GetPlaceRequest: MessageFns<GetPlaceRequest> = {
  encode(message: GetPlaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.placeId !== "") {
      writer.uint32(18).string(message.placeId);
    }
    for (const v of message.fields) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fields.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlaceRequest {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetPlaceRequest): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlaceRequest>, I>>(base?: I): GetPlaceRequest {
    return GetPlaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlaceRequest>, I>>(object: I): GetPlaceRequest {
    const message = createBaseGetPlaceRequest();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.placeId = object.placeId ?? "";
    message.fields = object.fields?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPlaceResponse(): GetPlaceResponse {
  return { result: undefined, status: "" };
}

export const GetPlaceResponse: MessageFns<GetPlaceResponse> = {
  encode(message: GetPlaceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      RawPlace.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPlaceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = RawPlace.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlaceResponse {
    return {
      result: isSet(object.result) ? RawPlace.fromJSON(object.result) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: GetPlaceResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RawPlace.toJSON(message.result);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlaceResponse>, I>>(base?: I): GetPlaceResponse {
    return GetPlaceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlaceResponse>, I>>(object: I): GetPlaceResponse {
    const message = createBaseGetPlaceResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? RawPlace.fromPartial(object.result)
      : undefined;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseTextSearchRequest(): TextSearchRequest {
  return { query: "", location: undefined, radius: 0, type: "", maxResults: 0, pageToken: "" };
}

export const TextSearchRequest: MessageFns<TextSearchRequest> = {
  encode(message: TextSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(18).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(24).int32(message.radius);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.maxResults !== 0) {
      writer.uint32(40).int32(message.maxResults);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.radius = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxResults = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextSearchRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      maxResults: isSet(object.maxResults) ? globalThis.Number(object.maxResults) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: TextSearchRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.maxResults !== 0) {
      obj.maxResults = Math.round(message.maxResults);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextSearchRequest>, I>>(base?: I): TextSearchRequest {
    return TextSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextSearchRequest>, I>>(object: I): TextSearchRequest {
    const message = createBaseTextSearchRequest();
    message.query = object.query ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.radius = object.radius ?? 0;
    message.type = object.type ?? "";
    message.maxResults = object.maxResults ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseTextSearchResponse(): TextSearchResponse {
  return { results: [], status: "", nextPageToken: "" };
}

export const TextSearchResponse: MessageFns<TextSearchResponse> = {
  encode(message: TextSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      RawPlace.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(RawPlace.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextSearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => RawPlace.fromJSON(e)) : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: TextSearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => RawPlace.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextSearchResponse>, I>>(base?: I): TextSearchResponse {
    return TextSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextSearchResponse>, I>>(object: I): TextSearchResponse {
    const message = createBaseTextSearchResponse();
    message.results = object.results?.map((e) => RawPlace.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseNearbySearchRequest(): NearbySearchRequest {
  return { location: undefined, radius: 0, keyword: "", type: "", maxResults: 0, pageToken: "" };
}

export const NearbySearchRequest: MessageFns<NearbySearchRequest> = {
  encode(message: NearbySearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(16).int32(message.radius);
    }
    if (message.keyword !== "") {
      writer.uint32(26).string(message.keyword);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.maxResults !== 0) {
      writer.uint32(40).int32(message.maxResults);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearbySearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearbySearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.radius = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyword = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxResults = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearbySearchRequest {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      keyword: isSet(object.keyword) ? globalThis.String(object.keyword) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      maxResults: isSet(object.maxResults) ? globalThis.Number(object.maxResults) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: NearbySearchRequest): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.keyword !== "") {
      obj.keyword = message.keyword;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.maxResults !== 0) {
      obj.maxResults = Math.round(message.maxResults);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NearbySearchRequest>, I>>(base?: I): NearbySearchRequest {
    return NearbySearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NearbySearchRequest>, I>>(object: I): NearbySearchRequest {
    const message = createBaseNearbySearchRequest();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.radius = object.radius ?? 0;
    message.keyword = object.keyword ?? "";
    message.type = object.type ?? "";
    message.maxResults = object.maxResults ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseNearbySearchResponse(): NearbySearchResponse {
  return { results: [], status: "", nextPageToken: "" };
}

export const NearbySearchResponse: MessageFns<NearbySearchResponse> = {
  encode(message: NearbySearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      RawPlace.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearbySearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearbySearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(RawPlace.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearbySearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => RawPlace.fromJSON(e)) : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: NearbySearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => RawPlace.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NearbySearchResponse>, I>>(base?: I): NearbySearchResponse {
    return NearbySearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NearbySearchResponse>, I>>(object: I): NearbySearchResponse {
    const message = createBaseNearbySearchResponse();
    message.results = object.results?.map((e) => RawPlace.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAutocompleteRequest(): AutocompleteRequest {
  return { input: "", location: undefined, radius: 0, types: [] };
}

export const AutocompleteRequest: MessageFns<AutocompleteRequest> = {
  encode(message: AutocompleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(18).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(24).int32(message.radius);
    }
    for (const v of message.types) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.radius = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.types.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompleteRequest {
    return {
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AutocompleteRequest): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutocompleteRequest>, I>>(base?: I): AutocompleteRequest {
    return AutocompleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutocompleteRequest>, I>>(object: I): AutocompleteRequest {
    const message = createBaseAutocompleteRequest();
    message.input = object.input ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.radius = object.radius ?? 0;
    message.types = object.types?.map((e) => e) || [];
    return message;
  },
};

function createBaseAutocompletePrediction(): AutocompletePrediction {
  return {
    description: "",
    placeId: "",
    reference: "",
    types: [],
    structuredFormatting: undefined,
    matchedSubstrings: [],
    terms: [],
  };
}

export const AutocompletePrediction: MessageFns<AutocompletePrediction> = {
  encode(message: AutocompletePrediction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.placeId !== "") {
      writer.uint32(18).string(message.placeId);
    }
    if (message.reference !== "") {
      writer.uint32(26).string(message.reference);
    }
    for (const v of message.types) {
      writer.uint32(34).string(v!);
    }
    if (message.structuredFormatting !== undefined) {
      StructuredFormatting.encode(message.structuredFormatting, writer.uint32(42).fork()).join();
    }
    for (const v of message.matchedSubstrings) {
      MatchedSubstring.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.terms) {
      Term.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompletePrediction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompletePrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.placeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.types.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.structuredFormatting = StructuredFormatting.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.matchedSubstrings.push(MatchedSubstring.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.terms.push(Term.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompletePrediction {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      reference: isSet(object.reference) ? globalThis.String(object.reference) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      structuredFormatting: isSet(object.structuredFormatting)
        ? StructuredFormatting.fromJSON(object.structuredFormatting)
        : undefined,
      matchedSubstrings: globalThis.Array.isArray(object?.matchedSubstrings)
        ? object.matchedSubstrings.map((e: any) => MatchedSubstring.fromJSON(e))
        : [],
      terms: globalThis.Array.isArray(object?.terms) ? object.terms.map((e: any) => Term.fromJSON(e)) : [],
    };
  },

  toJSON(message: AutocompletePrediction): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.reference !== "") {
      obj.reference = message.reference;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.structuredFormatting !== undefined) {
      obj.structuredFormatting = StructuredFormatting.toJSON(message.structuredFormatting);
    }
    if (message.matchedSubstrings?.length) {
      obj.matchedSubstrings = message.matchedSubstrings.map((e) => MatchedSubstring.toJSON(e));
    }
    if (message.terms?.length) {
      obj.terms = message.terms.map((e) => Term.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutocompletePrediction>, I>>(base?: I): AutocompletePrediction {
    return AutocompletePrediction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutocompletePrediction>, I>>(object: I): AutocompletePrediction {
    const message = createBaseAutocompletePrediction();
    message.description = object.description ?? "";
    message.placeId = object.placeId ?? "";
    message.reference = object.reference ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.structuredFormatting = (object.structuredFormatting !== undefined && object.structuredFormatting !== null)
      ? StructuredFormatting.fromPartial(object.structuredFormatting)
      : undefined;
    message.matchedSubstrings = object.matchedSubstrings?.map((e) => MatchedSubstring.fromPartial(e)) || [];
    message.terms = object.terms?.map((e) => Term.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructuredFormatting(): StructuredFormatting {
  return { mainText: "", mainTextMatchedSubstrings: [], secondaryText: "" };
}

export const StructuredFormatting: MessageFns<StructuredFormatting> = {
  encode(message: StructuredFormatting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mainText !== "") {
      writer.uint32(10).string(message.mainText);
    }
    for (const v of message.mainTextMatchedSubstrings) {
      MatchedSubstring.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.secondaryText !== "") {
      writer.uint32(26).string(message.secondaryText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredFormatting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredFormatting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mainText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mainTextMatchedSubstrings.push(MatchedSubstring.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secondaryText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredFormatting {
    return {
      mainText: isSet(object.mainText) ? globalThis.String(object.mainText) : "",
      mainTextMatchedSubstrings: globalThis.Array.isArray(object?.mainTextMatchedSubstrings)
        ? object.mainTextMatchedSubstrings.map((e: any) => MatchedSubstring.fromJSON(e))
        : [],
      secondaryText: isSet(object.secondaryText) ? globalThis.String(object.secondaryText) : "",
    };
  },

  toJSON(message: StructuredFormatting): unknown {
    const obj: any = {};
    if (message.mainText !== "") {
      obj.mainText = message.mainText;
    }
    if (message.mainTextMatchedSubstrings?.length) {
      obj.mainTextMatchedSubstrings = message.mainTextMatchedSubstrings.map((e) => MatchedSubstring.toJSON(e));
    }
    if (message.secondaryText !== "") {
      obj.secondaryText = message.secondaryText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StructuredFormatting>, I>>(base?: I): StructuredFormatting {
    return StructuredFormatting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StructuredFormatting>, I>>(object: I): StructuredFormatting {
    const message = createBaseStructuredFormatting();
    message.mainText = object.mainText ?? "";
    message.mainTextMatchedSubstrings = object.mainTextMatchedSubstrings?.map((e) => MatchedSubstring.fromPartial(e)) ||
      [];
    message.secondaryText = object.secondaryText ?? "";
    return message;
  },
};

function createBaseMatchedSubstring(): MatchedSubstring {
  return { length: 0, offset: 0 };
}

export const MatchedSubstring: MessageFns<MatchedSubstring> = {
  encode(message: MatchedSubstring, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.length !== 0) {
      writer.uint32(8).int32(message.length);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchedSubstring {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchedSubstring();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchedSubstring {
    return {
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: MatchedSubstring): unknown {
    const obj: any = {};
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchedSubstring>, I>>(base?: I): MatchedSubstring {
    return MatchedSubstring.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchedSubstring>, I>>(object: I): MatchedSubstring {
    const message = createBaseMatchedSubstring();
    message.length = object.length ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseTerm(): Term {
  return { offset: 0, value: "" };
}

export const Term: MessageFns<Term> = {
  encode(message: Term, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Term {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Term {
    return {
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Term): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Term>, I>>(base?: I): Term {
    return Term.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Term>, I>>(object: I): Term {
    const message = createBaseTerm();
    message.offset = object.offset ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAutocompleteResponse(): AutocompleteResponse {
  return { predictions: [], status: "" };
}

export const AutocompleteResponse: MessageFns<AutocompleteResponse> = {
  encode(message: AutocompleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.predictions) {
      AutocompletePrediction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutocompleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutocompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.predictions.push(AutocompletePrediction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutocompleteResponse {
    return {
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => AutocompletePrediction.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: AutocompleteResponse): unknown {
    const obj: any = {};
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => AutocompletePrediction.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutocompleteResponse>, I>>(base?: I): AutocompleteResponse {
    return AutocompleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutocompleteResponse>, I>>(object: I): AutocompleteResponse {
    const message = createBaseAutocompleteResponse();
    message.predictions = object.predictions?.map((e) => AutocompletePrediction.fromPartial(e)) || [];
    message.status = object.status ?? "";
    return message;
  },
};

export type PlaceServiceService = typeof PlaceServiceService;
export const PlaceServiceService = {
  getPlace: {
    path: "/place.PlaceService/GetPlace",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPlaceRequest): Buffer => Buffer.from(GetPlaceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPlaceRequest => GetPlaceRequest.decode(value),
    responseSerialize: (value: GetPlaceResponse): Buffer => Buffer.from(GetPlaceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPlaceResponse => GetPlaceResponse.decode(value),
  },
  textSearch: {
    path: "/place.PlaceService/TextSearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TextSearchRequest): Buffer => Buffer.from(TextSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TextSearchRequest => TextSearchRequest.decode(value),
    responseSerialize: (value: TextSearchResponse): Buffer => Buffer.from(TextSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TextSearchResponse => TextSearchResponse.decode(value),
  },
  nearbySearch: {
    path: "/place.PlaceService/NearbySearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NearbySearchRequest): Buffer => Buffer.from(NearbySearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NearbySearchRequest => NearbySearchRequest.decode(value),
    responseSerialize: (value: NearbySearchResponse): Buffer =>
      Buffer.from(NearbySearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NearbySearchResponse => NearbySearchResponse.decode(value),
  },
  autocomplete: {
    path: "/place.PlaceService/Autocomplete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AutocompleteRequest): Buffer => Buffer.from(AutocompleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AutocompleteRequest => AutocompleteRequest.decode(value),
    responseSerialize: (value: AutocompleteResponse): Buffer =>
      Buffer.from(AutocompleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AutocompleteResponse => AutocompleteResponse.decode(value),
  },
} as const;

export interface PlaceServiceServer extends UntypedServiceImplementation {
  getPlace: handleUnaryCall<GetPlaceRequest, GetPlaceResponse>;
  textSearch: handleUnaryCall<TextSearchRequest, TextSearchResponse>;
  nearbySearch: handleUnaryCall<NearbySearchRequest, NearbySearchResponse>;
  autocomplete: handleUnaryCall<AutocompleteRequest, AutocompleteResponse>;
}

export interface PlaceServiceClient extends Client {
  getPlace(
    request: GetPlaceRequest,
    callback: (error: ServiceError | null, response: GetPlaceResponse) => void,
  ): ClientUnaryCall;
  getPlace(
    request: GetPlaceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPlaceResponse) => void,
  ): ClientUnaryCall;
  getPlace(
    request: GetPlaceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPlaceResponse) => void,
  ): ClientUnaryCall;
  textSearch(
    request: TextSearchRequest,
    callback: (error: ServiceError | null, response: TextSearchResponse) => void,
  ): ClientUnaryCall;
  textSearch(
    request: TextSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TextSearchResponse) => void,
  ): ClientUnaryCall;
  textSearch(
    request: TextSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TextSearchResponse) => void,
  ): ClientUnaryCall;
  nearbySearch(
    request: NearbySearchRequest,
    callback: (error: ServiceError | null, response: NearbySearchResponse) => void,
  ): ClientUnaryCall;
  nearbySearch(
    request: NearbySearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NearbySearchResponse) => void,
  ): ClientUnaryCall;
  nearbySearch(
    request: NearbySearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NearbySearchResponse) => void,
  ): ClientUnaryCall;
  autocomplete(
    request: AutocompleteRequest,
    callback: (error: ServiceError | null, response: AutocompleteResponse) => void,
  ): ClientUnaryCall;
  autocomplete(
    request: AutocompleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AutocompleteResponse) => void,
  ): ClientUnaryCall;
  autocomplete(
    request: AutocompleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AutocompleteResponse) => void,
  ): ClientUnaryCall;
}

export const PlaceServiceClient = makeGenericClientConstructor(
  PlaceServiceService,
  "place.PlaceService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PlaceServiceClient;
  service: typeof PlaceServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
