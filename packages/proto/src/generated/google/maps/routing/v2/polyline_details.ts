// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.24.4
// source: google/maps/routing/v2/polyline_details.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "google.maps.routing.v2";

/**
 * Details corresponding to a given index or contiguous segment of a polyline.
 * Given a polyline with points P_0, P_1, ... , P_N (zero-based index), the
 * `PolylineDetails` defines an interval and associated metadata.
 */
export interface PolylineDetails {
  /** Flyover details along the polyline. */
  flyoverInfo: PolylineDetails_FlyoverInfo[];
  /** Narrow road details along the polyline. */
  narrowRoadInfo: PolylineDetails_NarrowRoadInfo[];
}

/** Encapsulates the states of road features along a stretch of polyline. */
export enum PolylineDetails_RoadFeatureState {
  /** ROAD_FEATURE_STATE_UNSPECIFIED - The road feature's state was not computed (default value). */
  ROAD_FEATURE_STATE_UNSPECIFIED = 0,
  /** EXISTS - The road feature exists. */
  EXISTS = 1,
  /** DOES_NOT_EXIST - The road feature does not exist. */
  DOES_NOT_EXIST = 2,
  UNRECOGNIZED = -1,
}

export function polylineDetails_RoadFeatureStateFromJSON(object: any): PolylineDetails_RoadFeatureState {
  switch (object) {
    case 0:
    case "ROAD_FEATURE_STATE_UNSPECIFIED":
      return PolylineDetails_RoadFeatureState.ROAD_FEATURE_STATE_UNSPECIFIED;
    case 1:
    case "EXISTS":
      return PolylineDetails_RoadFeatureState.EXISTS;
    case 2:
    case "DOES_NOT_EXIST":
      return PolylineDetails_RoadFeatureState.DOES_NOT_EXIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolylineDetails_RoadFeatureState.UNRECOGNIZED;
  }
}

export function polylineDetails_RoadFeatureStateToJSON(object: PolylineDetails_RoadFeatureState): string {
  switch (object) {
    case PolylineDetails_RoadFeatureState.ROAD_FEATURE_STATE_UNSPECIFIED:
      return "ROAD_FEATURE_STATE_UNSPECIFIED";
    case PolylineDetails_RoadFeatureState.EXISTS:
      return "EXISTS";
    case PolylineDetails_RoadFeatureState.DOES_NOT_EXIST:
      return "DOES_NOT_EXIST";
    case PolylineDetails_RoadFeatureState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Encapsulates the start and end indexes for a polyline detail.
 * For instances where the data corresponds to a single point, `start_index`
 * and `end_index` will be equal.
 */
export interface PolylineDetails_PolylinePointIndex {
  /** The start index of this detail in the polyline. */
  startIndex?:
    | number
    | undefined;
  /** The end index of this detail in the polyline. */
  endIndex?: number | undefined;
}

/** Encapsulates information about flyovers along the polyline. */
export interface PolylineDetails_FlyoverInfo {
  /**
   * Output only. Denotes whether a flyover exists for a given stretch of the
   * polyline.
   */
  flyoverPresence: PolylineDetails_RoadFeatureState;
  /** The location of flyover related information along the polyline. */
  polylinePointIndex: PolylineDetails_PolylinePointIndex | undefined;
}

/** Encapsulates information about narrow roads along the polyline. */
export interface PolylineDetails_NarrowRoadInfo {
  /**
   * Output only. Denotes whether a narrow road exists for a given stretch of
   * the polyline.
   */
  narrowRoadPresence: PolylineDetails_RoadFeatureState;
  /** The location of narrow road related information along the polyline. */
  polylinePointIndex: PolylineDetails_PolylinePointIndex | undefined;
}

function createBasePolylineDetails(): PolylineDetails {
  return { flyoverInfo: [], narrowRoadInfo: [] };
}

export const PolylineDetails: MessageFns<PolylineDetails> = {
  encode(message: PolylineDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flyoverInfo) {
      PolylineDetails_FlyoverInfo.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.narrowRoadInfo) {
      PolylineDetails_NarrowRoadInfo.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolylineDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolylineDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.flyoverInfo.push(PolylineDetails_FlyoverInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.narrowRoadInfo.push(PolylineDetails_NarrowRoadInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolylineDetails {
    return {
      flyoverInfo: globalThis.Array.isArray(object?.flyoverInfo)
        ? object.flyoverInfo.map((e: any) => PolylineDetails_FlyoverInfo.fromJSON(e))
        : [],
      narrowRoadInfo: globalThis.Array.isArray(object?.narrowRoadInfo)
        ? object.narrowRoadInfo.map((e: any) => PolylineDetails_NarrowRoadInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolylineDetails): unknown {
    const obj: any = {};
    if (message.flyoverInfo?.length) {
      obj.flyoverInfo = message.flyoverInfo.map((e) => PolylineDetails_FlyoverInfo.toJSON(e));
    }
    if (message.narrowRoadInfo?.length) {
      obj.narrowRoadInfo = message.narrowRoadInfo.map((e) => PolylineDetails_NarrowRoadInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolylineDetails>, I>>(base?: I): PolylineDetails {
    return PolylineDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolylineDetails>, I>>(object: I): PolylineDetails {
    const message = createBasePolylineDetails();
    message.flyoverInfo = object.flyoverInfo?.map((e) => PolylineDetails_FlyoverInfo.fromPartial(e)) || [];
    message.narrowRoadInfo = object.narrowRoadInfo?.map((e) => PolylineDetails_NarrowRoadInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolylineDetails_PolylinePointIndex(): PolylineDetails_PolylinePointIndex {
  return { startIndex: undefined, endIndex: undefined };
}

export const PolylineDetails_PolylinePointIndex: MessageFns<PolylineDetails_PolylinePointIndex> = {
  encode(message: PolylineDetails_PolylinePointIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== undefined) {
      writer.uint32(8).int32(message.startIndex);
    }
    if (message.endIndex !== undefined) {
      writer.uint32(16).int32(message.endIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolylineDetails_PolylinePointIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolylineDetails_PolylinePointIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolylineDetails_PolylinePointIndex {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : undefined,
      endIndex: isSet(object.endIndex) ? globalThis.Number(object.endIndex) : undefined,
    };
  },

  toJSON(message: PolylineDetails_PolylinePointIndex): unknown {
    const obj: any = {};
    if (message.startIndex !== undefined) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.endIndex !== undefined) {
      obj.endIndex = Math.round(message.endIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolylineDetails_PolylinePointIndex>, I>>(
    base?: I,
  ): PolylineDetails_PolylinePointIndex {
    return PolylineDetails_PolylinePointIndex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolylineDetails_PolylinePointIndex>, I>>(
    object: I,
  ): PolylineDetails_PolylinePointIndex {
    const message = createBasePolylineDetails_PolylinePointIndex();
    message.startIndex = object.startIndex ?? undefined;
    message.endIndex = object.endIndex ?? undefined;
    return message;
  },
};

function createBasePolylineDetails_FlyoverInfo(): PolylineDetails_FlyoverInfo {
  return { flyoverPresence: 0, polylinePointIndex: undefined };
}

export const PolylineDetails_FlyoverInfo: MessageFns<PolylineDetails_FlyoverInfo> = {
  encode(message: PolylineDetails_FlyoverInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flyoverPresence !== 0) {
      writer.uint32(8).int32(message.flyoverPresence);
    }
    if (message.polylinePointIndex !== undefined) {
      PolylineDetails_PolylinePointIndex.encode(message.polylinePointIndex, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolylineDetails_FlyoverInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolylineDetails_FlyoverInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.flyoverPresence = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.polylinePointIndex = PolylineDetails_PolylinePointIndex.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolylineDetails_FlyoverInfo {
    return {
      flyoverPresence: isSet(object.flyoverPresence)
        ? polylineDetails_RoadFeatureStateFromJSON(object.flyoverPresence)
        : 0,
      polylinePointIndex: isSet(object.polylinePointIndex)
        ? PolylineDetails_PolylinePointIndex.fromJSON(object.polylinePointIndex)
        : undefined,
    };
  },

  toJSON(message: PolylineDetails_FlyoverInfo): unknown {
    const obj: any = {};
    if (message.flyoverPresence !== 0) {
      obj.flyoverPresence = polylineDetails_RoadFeatureStateToJSON(message.flyoverPresence);
    }
    if (message.polylinePointIndex !== undefined) {
      obj.polylinePointIndex = PolylineDetails_PolylinePointIndex.toJSON(message.polylinePointIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolylineDetails_FlyoverInfo>, I>>(base?: I): PolylineDetails_FlyoverInfo {
    return PolylineDetails_FlyoverInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolylineDetails_FlyoverInfo>, I>>(object: I): PolylineDetails_FlyoverInfo {
    const message = createBasePolylineDetails_FlyoverInfo();
    message.flyoverPresence = object.flyoverPresence ?? 0;
    message.polylinePointIndex = (object.polylinePointIndex !== undefined && object.polylinePointIndex !== null)
      ? PolylineDetails_PolylinePointIndex.fromPartial(object.polylinePointIndex)
      : undefined;
    return message;
  },
};

function createBasePolylineDetails_NarrowRoadInfo(): PolylineDetails_NarrowRoadInfo {
  return { narrowRoadPresence: 0, polylinePointIndex: undefined };
}

export const PolylineDetails_NarrowRoadInfo: MessageFns<PolylineDetails_NarrowRoadInfo> = {
  encode(message: PolylineDetails_NarrowRoadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.narrowRoadPresence !== 0) {
      writer.uint32(8).int32(message.narrowRoadPresence);
    }
    if (message.polylinePointIndex !== undefined) {
      PolylineDetails_PolylinePointIndex.encode(message.polylinePointIndex, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolylineDetails_NarrowRoadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolylineDetails_NarrowRoadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.narrowRoadPresence = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.polylinePointIndex = PolylineDetails_PolylinePointIndex.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolylineDetails_NarrowRoadInfo {
    return {
      narrowRoadPresence: isSet(object.narrowRoadPresence)
        ? polylineDetails_RoadFeatureStateFromJSON(object.narrowRoadPresence)
        : 0,
      polylinePointIndex: isSet(object.polylinePointIndex)
        ? PolylineDetails_PolylinePointIndex.fromJSON(object.polylinePointIndex)
        : undefined,
    };
  },

  toJSON(message: PolylineDetails_NarrowRoadInfo): unknown {
    const obj: any = {};
    if (message.narrowRoadPresence !== 0) {
      obj.narrowRoadPresence = polylineDetails_RoadFeatureStateToJSON(message.narrowRoadPresence);
    }
    if (message.polylinePointIndex !== undefined) {
      obj.polylinePointIndex = PolylineDetails_PolylinePointIndex.toJSON(message.polylinePointIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolylineDetails_NarrowRoadInfo>, I>>(base?: I): PolylineDetails_NarrowRoadInfo {
    return PolylineDetails_NarrowRoadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolylineDetails_NarrowRoadInfo>, I>>(
    object: I,
  ): PolylineDetails_NarrowRoadInfo {
    const message = createBasePolylineDetails_NarrowRoadInfo();
    message.narrowRoadPresence = object.narrowRoadPresence ?? 0;
    message.polylinePointIndex = (object.polylinePointIndex !== undefined && object.polylinePointIndex !== null)
      ? PolylineDetails_PolylinePointIndex.fromPartial(object.polylinePointIndex)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
